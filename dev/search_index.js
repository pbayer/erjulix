var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = Erjulix","category":"page"},{"location":"#Erjulix","page":"Home","title":"Erjulix","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Connect Erlang, Julia and Elixir","category":"page"},{"location":"","page":"Home","title":"Home","text":"Documentation for Erjulix.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [Erjulix]","category":"page"},{"location":"#Erjulix.EvalServer-Tuple{Sockets.UDPSocket, Module}","page":"Home","title":"Erjulix.EvalServer","text":"EvalServer(port::Integer, mod::Module)\n\nAn EvalServer runs as a task with its own module namespace. It receives UDP message tuples from Erlang:\n\n(:eval, term): where term is a Symbol or a String,\n(:call, term, args): with term as above and args a Vector{Any},\n(:set, atoms, vals): where atoms is a Symbol or a vector   of them and vals is a value Any or a vector of them.\n\nIt then evaluates the messages in its namespace as\n\nstrings to parse or symbols to evaluate,\nfunctions to execute with arguments or \nvariables to create or to assign values to.\n\nIt sends a result tuple back to the Erlang client.\n\nThe server finishes if it gets an \"exit\" or :exit message. \n\n\n\n\n\n","category":"method"},{"location":"#Erjulix.eServer-Tuple{Sockets.IPAddr, Integer}","page":"Home","title":"Erjulix.eServer","text":"eServer(port::Integer)\n\nCreate a module with an EvalServer listening to an UDP port  in its namespace and return the module. \n\n\n\n\n\n","category":"method"},{"location":"#Erjulix.pServer-Tuple{Sockets.IPAddr, Integer}","page":"Home","title":"Erjulix.pServer","text":"pServer(port::Integer)\npServer(host::IPAddr, port::Integer)\n\nStart a server listening to an UDP port and starting  parallel EvalServers if requested. \n\n\n\n\n\n","category":"method"}]
}
