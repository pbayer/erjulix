var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = Erjulix","category":"page"},{"location":"#Erjulix","page":"Home","title":"Erjulix","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Connect Erlang, Julia and Elixir","category":"page"},{"location":"","page":"Home","title":"Home","text":"Documentation for Erjulix.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [Erjulix]","category":"page"},{"location":"#Erjulix.Erjulix","page":"Home","title":"Erjulix.Erjulix","text":"Erjulix\n\nJulia module for communicating with Erlang and Elixir.\n\n\n\n\n\n","category":"module"},{"location":"#Erjulix.EvalServer-Tuple{Sockets.UDPSocket, Module, AbstractString}","page":"Home","title":"Erjulix.EvalServer","text":"EvalServer(port::Integer, mod::Module, key::AbstractString)\n\nAn EvalServer runs as a task with its own module namespace. It receives UDP message tuples from Erlang:\n\n(:eval, term): where term is a Symbol or a String,\n(:call, term, args): with term as above and args a Vector{Any},\n(:set, atoms, vals): where atoms is a Symbol or a vector   of them and vals is a value Any or a vector of them.\n\nIt then evaluates the messages in its namespace as\n\nstrings to parse or symbols to evaluate,\nfunctions to execute with arguments or \nvariables to create or to assign values to.\n\nIt sends a result tuple back to the Erlang client.\n\nThe server finishes if it gets an \"exit\" or :exit message.\n\nIf !isempty(key), the UDP packages get sha-256 encoded/decoded  with that key as JSON Web tokens.\n\n\n\n\n\n","category":"method"},{"location":"#Erjulix.deserializek-Tuple{Vector{UInt8}, AbstractString}","page":"Home","title":"Erjulix.deserializek","text":"Deserialize a binary, sha-256 decoded with key if it is not empty.\n\n\n\n\n\n","category":"method"},{"location":"#Erjulix.eServer-Tuple{Sockets.IPAddr, Integer, AbstractString}","page":"Home","title":"Erjulix.eServer","text":"eServer(host::IPAddr, port::Integer, key::AbstractString)\neServer(port::Integer)\n\nCreate a module and spawn an EvalServer listening to an UDP port  in its namespace and return the module. \n\n\n\n\n\n","category":"method"},{"location":"#Erjulix.genpasswd-Tuple{Any}","page":"Home","title":"Erjulix.genpasswd","text":"Return a Base64 encoded random passwort of length len.\n\n\n\n\n\n","category":"method"},{"location":"#Erjulix.getHostPort-Tuple{Sockets.UDPSocket}","page":"Home","title":"Erjulix.getHostPort","text":"Return the Sockets.InetAddr of a socket sock.\n\n\n\n\n\n","category":"method"},{"location":"#Erjulix.getPort-Tuple{Integer}","page":"Home","title":"Erjulix.getPort","text":"Return an available port number â‰¥ start.\n\n\n\n\n\n","category":"method"},{"location":"#Erjulix.pServer-Tuple{Sockets.IPAddr, Integer, AbstractString}","page":"Home","title":"Erjulix.pServer","text":"pServer(port::Integer)\npServer(host::IPAddr, port::Integer, key::AbstractString)\n\nStart a server listening to an UDP port and starting  parallel EvalServers if requested. \n\n\n\n\n\n","category":"method"},{"location":"#Erjulix.serializek-Tuple{Any, AbstractString}","page":"Home","title":"Erjulix.serializek","text":"Serialize data, sha-256 encoded with key if it is not empty.\n\n\n\n\n\n","category":"method"}]
}
